##OpenGL管线知识

####OpenGL Context

在说OpenGL具体管线之前，先说一下OpenGL Context。在调用任何OpenGL函数之前，必须已经创建了GL Context， GL Context存储了OpenGL的状态变量以及其他渲染有关的信息。OpenGL是个状态机，有很多状态变量，是一个标准的过程式操作过程，改变状态会影响后续所有操作。

OpenGL采用Client-Server模型来解释OpenGL程序，即Server存储GL Context，Client提出渲染请求，Server给予响应。

一个简单的游戏循环：
```sh
while(!glfwWindowShouldClose(window))
{
  glfwPollEvents();
  glfwSwapBuffers(window);
}
```
- glfwWindowShouldClose()		检查GLFW是否被关闭
- glfwPollEvents()				检查是否有触发事件
- glfwSwapBuffers()			交换颜色缓冲

####关于双缓冲(Double Buffer)

应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。前缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。当所有的渲染指令执行完毕后，我们交换(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了.

#####管线总结：

顶点数据(Vertices) -> 顶点着色器(Vertex Shader) -> 图元装配(Assembly) -> 几何着色器(Geometry Shader) -> 光栅化(Rasterization) -> 片断着色器(Fragment Shader) -> 逐片断处理(Per-Fragment Operations) -> 帧缓冲(FrameBuffer) -> 双缓冲交换(SwapBuffer)

#####在OpenGL中这个过程可以分为四个阶段：

- 顶点处理	： 主要进行顶点齐次坐标变换和光照
- 图元装配  ： 对图元进行投影变换和平面裁剪，变换到裁剪坐标系，再经过透视除法和视口变换从而将三维场景映射到窗口的区域坐标中。
- 光栅化： 光栅化的任务是构造顶点之间的线段、多边形的边和内部，将顶点信息进行“方块化（和屏幕像素对应）”，再转换为片断信息。
- 逐片断处理： 光栅化输出的片断在此进入逐片断处理，首先进行各种测试，不通过的片断将被丢弃从而不能进入后续操作，然后进行一些操作（如混合），最终将被写入FrameBuffer用于最终屏幕显示。

#####在Unity的渲染流程中，则分为五个过程：

- 应用程序阶段 : CPU计算好，物体的顶点坐标、法向量、纹理坐标、纹理等数据，然后传给通过数据总线传给图形硬件。
- 顶点处理   : 完成一系列的坐标系转换，再进行材质属性和光照等处理。
- 面处理   ：包括剔除和截取，主要是为了效率考虑，将屏幕外的面截取掉，屏幕内被遮挡的面剔除掉。
- 光栅化    ：将以向量为基本结构的面转换成一个个点阵形式的像素。
- 像素处理   ：对像素区域进行着色和贴图处理。